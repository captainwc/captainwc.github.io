<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法s on SHUAIKAI&#39;s Blog</title>
    <link>https://kaikaixixi.xyz/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法s on SHUAIKAI&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 14 Mar 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kaikaixixi.xyz/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>leetcode调试指南</title>
      <link>https://kaikaixixi.xyz/%E7%AE%97%E6%B3%95/leetcode%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/</link>
      <pubDate>Thu, 14 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://kaikaixixi.xyz/%E7%AE%97%E6%B3%95/leetcode%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;h1 id=&#34;leetcode-调试&#34;&gt;leetcode 调试&lt;/h1&gt;&#xA;&lt;h2 id=&#34;方法-2&#34;&gt;方法 2&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;代码拷贝到本地，用 ide/gdb 调试。&#xA;比如使用 vim + floaterm + cgdb，效果见后图&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;对于此法，提供一个 &lt;strong&gt;header-only&lt;/strong&gt; 的头文件 📜&#xA;&lt;a href=&#34;https://shuaikai-bucket0001.oss-cn-shanghai.aliyuncs.com/pic_bed/2024_7/lc.h&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;《lc.h》&lt;/a&gt;&#xA;，只需要引用此头文件，然后将 Class Solution 复制到本地，加上 main 函数即可运行&lt;/p&gt;&#xA;&lt;h3 id=&#34;功能简介&#34;&gt;功能简介&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;常用头文件（类似&amp;lt;bits/stdc++.h&amp;gt;，但是 win 上没有）以及 &lt;code&gt;using namespace std;&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;leetcode 的链表和二叉树的定义，以及快速构建函数&lt;/li&gt;&#xA;&lt;li&gt;随机数库封装，可以直接获取随机 vector、字符串等&lt;/li&gt;&#xA;&lt;li&gt;Logger，可以打印包括&lt;strong&gt;容器&lt;/strong&gt;、&lt;strong&gt;嵌套容器&lt;/strong&gt;、&lt;strong&gt;自定义类型&lt;/strong&gt;在内的各种类型&lt;/li&gt;&#xA;&lt;li&gt;Assert, 一些断言。是的，这跟 leetcode 无关，可以在你编写自己的小算法的时候提供一些测试套件。效果如图：&lt;/li&gt;&#xA;&lt;li&gt;benchmark，简单的性能测试（测试运行 n 次用时、平均每次用时）&lt;/li&gt;&#xA;&lt;li&gt;其他的，大杂烩。（比如对 ppm 位图的封装，你可以由此实现一个对可视化的排序算法&amp;hellip;）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;效果图&#34;&gt;效果图&lt;/h3&gt;&#xA;&lt;p&gt;另外，推荐使用 &lt;strong&gt;vim + floaterm + cgdb&lt;/strong&gt; 的方式，配合此头文件对 leetcode 代码进行调试，喜欢的点是比较轻量，随时随地能调一下子。效果如下&lt;/p&gt;&#xA;&lt;div class=&#34;img-align&#34;&gt;&#xA;    &lt;img src=&#34;https://shuaikai-bucket0001.oss-cn-shanghai.aliyuncs.com/pic_bed/2025_3/1742197049941.png&#34;&gt;&#xA;    &lt;img src=&#34;https://shuaikai-bucket0001.oss-cn-shanghai.aliyuncs.com/pic_bed/2025_3/1742197079944.png&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;方法-1&#34;&gt;方法 1&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在 leetcode 代码头上定义测试宏，使用 print 大法来调试。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这里我把代码用 vscode 的 join line 合并成一行了，不然有些喧宾夺主。记得&lt;strong&gt;提交的时候把 DEBUG 宏关闭&lt;/strong&gt;就好。格式化后的代码见后文&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode刷题指南</title>
      <link>https://kaikaixixi.xyz/%E7%AE%97%E6%B3%95/leetcode%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://kaikaixixi.xyz/%E7%AE%97%E6%B3%95/leetcode%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;h2 id=&#34;1-数据结构&#34;&gt;1. 数据结构&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-数组&#34;&gt;1.1 数组&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;循环数组问题&lt;/strong&gt;：把数组扩大为两倍即可，但不是真的扩大两倍，而是通过索引取模的方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;12-链表&#34;&gt;1.2 链表&lt;/h3&gt;&#xA;&lt;p&gt;链表可以通过引入虚拟头节点 &lt;code&gt;ListNode *dummy = new ListNode{-1, nullptr}&lt;/code&gt; 来极大简化&lt;/p&gt;&#xA;&lt;ol start=&#34;0&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;**递归：**要区分基础情况和跳出情况，即可以有两种 return，比如：如果链表为空，那么返回。这时候的 return 并非是用来跳出递归的，而是一个 base 情况的判断，只有最基本的（最后一层递归）会用到。一系列操作，比如反转链表之后，再 return，则时候是退出递归的 return，即后面每一层递归想出栈都是走的这一条 return。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;反转链表&lt;/strong&gt;【递归】：反转从 &lt;code&gt;head-&amp;gt;next&lt;/code&gt; 开始的链表，然后拼接上第一个节点。&lt;strong&gt;base&lt;/strong&gt;：单节点链表&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;反转前 n 个元素&lt;/strong&gt;：反转从 &lt;code&gt;head-&amp;gt;next&lt;/code&gt; 开始的 &lt;code&gt;n-1&lt;/code&gt; 个元素，然后拼接。&lt;strong&gt;base&lt;/strong&gt;：n = 1&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;反转 [m, n] 的元素&lt;/strong&gt;：反转从 &lt;code&gt;head-&amp;gt;next&lt;/code&gt; 开始的 &lt;code&gt;[m-1, n - 1]&lt;/code&gt; 的元素，然后拼接。&lt;strong&gt;base&lt;/strong&gt;：m = 1，同上&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;倒序输出链表&lt;/strong&gt;：对链表进行&lt;mark&gt;后序遍历&lt;/mark&gt;，（递归的 base 是，head==nil）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;13-栈与队列&#34;&gt;1.3 栈与队列&lt;/h3&gt;&#xA;&lt;h4 id=&#34;单调队列&#34;&gt;单调队列&lt;/h4&gt;&#xA;&lt;p&gt;有这样一类问题：如何得到一个&lt;strong&gt;队列中的最值&lt;/strong&gt;？遍历，然后维护一个最值就好了。但这会有一个问题：当最值出队之后，次最值无从得知，需要再次遍历。可以参考例题：&lt;/p&gt;&#xA;&lt;p&gt;【&#xA;&lt;a href=&#34;https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;剑指 Offer：队列最大值&lt;/a&gt;&#xA;】，【&#xA;&lt;a href=&#34;https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;leetcode-1438. 绝对差不超过限制的最长连续子数组（解法二）&lt;/a&gt;&#xA;】&lt;/p&gt;&#xA;&lt;p&gt;如何快速得到一个队列中，&lt;em&gt;当前所有元素&lt;/em&gt;的最值呢？维护一个单调队列 queueMax，对入队元素 Value，如果 &lt;code&gt;queueMax.back() &amp;gt; value&lt;/code&gt;，则直接入队，否则一直 &lt;code&gt;queueMax.pop_back()&lt;/code&gt;，直至满足该条件。这样便可以保证：对原队列中所有元素，单调队列的队首，总是其最大值。如果原队列出队，使得最值出队，则单调队列中的下一个，仍是原队列中剩余元素的最值。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
