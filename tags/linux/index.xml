<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on SHUAIKAI&#39;s Blog</title>
    <link>https://kaikaixixi.xyz/tags/linux/</link>
    <description>Recent content in Linux on SHUAIKAI&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 14 Mar 2025 15:39:01 +0000</lastBuildDate>
    <atom:link href="https://kaikaixixi.xyz/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux环境变量加载顺序分析</title>
      <link>https://kaikaixixi.xyz/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90/</link>
      <pubDate>Fri, 14 Mar 2025 15:39:01 +0000</pubDate>
      <guid>https://kaikaixixi.xyz/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/linux%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;linux环境变量加载顺序分析&#34;&gt;Linux环境变量加载顺序分析&lt;/h1&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;环境变量是shell运行时的运行参数，比如执行命令时，就会从PATH指定的路径查找可执行文件。有的程序也会使用环境变量作为参数。&lt;br&gt;&#xA;当你发现配置了环境变量，但实际使用时环境变量未生效时，希望这篇文章能对你有所帮助。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;我们登录linux有很多种，bash来交互式执行，或者直接非交互式执行命令。试验后，可以发现，原来这几个的环境变量加载都是不同的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;相关文件&#34;&gt;相关文件：&lt;/h3&gt;&#xA;&lt;p&gt;电脑上和初始化相关的是这几个文件。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/etc/profile&#xA;/etc/environment&#xA;/etc/bashrc&#xA;~/.bash_profile&#xA;~/.bashrc&#xA;~/.bash_logout&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;bash登录方式和环境变量的关系&#34;&gt;bash登录方式和环境变量的关系：&lt;/h2&gt;&#xA;&lt;h3 id=&#34;环境加载和4种bash模式相关&#34;&gt;环境加载和4种bash模式相关。&lt;/h3&gt;&#xA;&lt;h4 id=&#34;什么是交互式shellinteractive-shell和非交互式shellnon-interactive-shell&#34;&gt;什么是交互式shell（interactive shell）和非交互式shell（non-interactive shell）：&lt;/h4&gt;&#xA;&lt;p&gt;交互式的shell会有一个输入提示符，并且它的标准输入、输出和错误输出都会显示在控制台上。所以一般来说只要是需要用户交互的。&lt;br&gt;&#xA;非交互式shell是 bash script.sh 这类的shell，脚本或程序执行完就结束了，没有交互。&lt;/p&gt;&#xA;&lt;h4 id=&#34;登录式shelllogin-shell和非登陆式shellno-login-shell&#34;&gt;登录式shell（login shell）和非登陆式shell（no-login shell）：&lt;/h4&gt;&#xA;&lt;p&gt;需要输入用户名和密码的shell就是登陆式shell。因此通常不管以何种方式登陆机器后用户获得的第一个shell就是login shell。不输入密码的ssh是公钥打通的，某种意义上说也是输入密码的。&lt;br&gt;&#xA;非登陆式的就是在登陆后启动bash等，即不是远程登陆到主机这种。&lt;/p&gt;&#xA;&lt;h3 id=&#34;不同方式的加载情况&#34;&gt;不同方式的加载情况：&lt;/h3&gt;&#xA;&lt;p&gt;以下是实验结果，可直接参考&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;文件&lt;/th&gt;&#xA;          &lt;th&gt;登陆 + 非交互&lt;/th&gt;&#xA;          &lt;th&gt;登陆 + 交互&lt;/th&gt;&#xA;          &lt;th&gt;非登陆 + 交互&lt;/th&gt;&#xA;          &lt;th&gt;非登陆 + 非交互&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;/etc/profile&lt;/td&gt;&#xA;          &lt;td&gt;加载&lt;/td&gt;&#xA;          &lt;td&gt;加载&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;/etc/environment&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;/etc/bashrc&lt;/td&gt;&#xA;          &lt;td&gt;加载&lt;/td&gt;&#xA;          &lt;td&gt;加载&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;~/.bash_profile&lt;/td&gt;&#xA;          &lt;td&gt;加载&lt;/td&gt;&#xA;          &lt;td&gt;加载&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;~/.bashrc&lt;/td&gt;&#xA;          &lt;td&gt;加载&lt;/td&gt;&#xA;          &lt;td&gt;加载&lt;/td&gt;&#xA;          &lt;td&gt;加载&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;BASH_ENV&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;加载&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;场景分析&#34;&gt;场景分析&lt;/h2&gt;&#xA;&lt;h4 id=&#34;常见的几种场景&#34;&gt;常见的几种场景&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;登陆机器后的第一个shell&lt;/strong&gt;​：登录+交互(login + interactive)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;新启动一个shell进程，如运行bash&lt;/strong&gt;​：非登录+交互(non-login + interactive)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;执行脚本，如bash script.sh&lt;/strong&gt;​：非登录+非交互(non-login + non-interactive))&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;运行头部有如#!/usr/bin/env bash的可执行文件，如./executable&lt;/strong&gt;​：非登录+非交互(non-login + non-interactive))&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;远程执行脚本，如 ssh user@remote script.sh&lt;/strong&gt;​：非登录+非交互(non-login + non-interactive))&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;远程执行脚本，同时-t强制分配伪终端，如ssh user@remote -t ‘echo&lt;/strong&gt;  &lt;strong&gt;$PWD’&lt;/strong&gt;  ：非登录+交互(non-login + interactive)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;在图形化界面中打开terminal，Linux上&lt;/strong&gt;: 非登录+交互(non-login + interactive)&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;在图形化界面中打开terminal，Mac OS X上&lt;/strong&gt;: 登录+交互(login + interactive)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;实验&#34;&gt;实验:&lt;/h2&gt;&#xA;&lt;h3 id=&#34;准备&#34;&gt;准备&lt;/h3&gt;&#xA;&lt;p&gt;在每个文件的开头和结尾都加了行输出用于打印状态。&lt;/p&gt;</description>
    </item>
    <item>
      <title>linux命令行大记忆恢复术</title>
      <link>https://kaikaixixi.xyz/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%94%A8%E6%B3%95/</link>
      <pubDate>Sat, 25 Nov 2023 00:00:00 +0000</pubDate>
      <guid>https://kaikaixixi.xyz/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%94%A8%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;常用-linux-命令&#34;&gt;常用 Linux 命令&lt;/h1&gt;&#xA;&lt;h2 id=&#34;find--fd&#34;&gt;find &amp;amp; fd&lt;/h2&gt;&#xA;&lt;p&gt;fd 默认是正则表达式状态，以及会忽略一些文件&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;-g&lt;/code&gt; 使用 glob 通配符&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; 查找拓展名&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-x&lt;/code&gt; 为每一条结果分别执行命令&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-X&lt;/code&gt; 为所有结果执行同一个命令&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-h&lt;/code&gt; 不跳过隐藏文件&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-uu&lt;/code&gt; 不忽略任何东西,包括.gitnore 中的&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; 忽略大小写(fd 默认是只能匹配,即输入小写是大小写不敏感,输入大写时敏感)&lt;/li&gt;&#xA;&lt;li&gt;权限&#xA;&lt;code&gt;find . -perm /111 -type f -delete&lt;/code&gt;：linux 下删除可执行文件（加个 type 可以略掉文件夹）（&#xA;&lt;a href=&#34;http://c.biancheng.net/view/779.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;find 命令参考&lt;/a&gt;&#xA;）&#xA;&lt;code&gt;-perm mode&lt;/code&gt;：必须与 mode 指示的一样&#xA;&lt;code&gt;-perm /mode&lt;/code&gt;：mode 中表示的，满足一个就好了，比如&lt;code&gt;111&lt;/code&gt;，则只要有一个&lt;code&gt;1&lt;/code&gt;满足就好了&#xA;&lt;code&gt;-perm -mode&lt;/code&gt;：mode 中表示的，必须全部具有，&lt;code&gt;111&lt;/code&gt;就是 ugo 都得可执行，缺一不可。别的属性不管&#xA;&lt;code&gt;find -iname readme -o -name *.c -not -size +100k -exec ls -i {} + -fprintf0 file.txt  &lt;/code&gt;：&#xA;find 查找是&lt;strong&gt;完全匹配&lt;/strong&gt;；逻辑与或非；size 的单位注意默认不是 byte；exec 结尾是&lt;code&gt;{} +&lt;/code&gt;大括号表示结果&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;diff&#34;&gt;diff&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;diff file1 file2&lt;/code&gt;：比较文件的异同：&lt;strong&gt;怎么样改变第一个文件，可以把它变成第二个文件&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; 表示左边 file1 独有的文件/行，&lt;code&gt;&amp;gt;&lt;/code&gt;表示右边 file2 独有的文件/行，&lt;code&gt;|&lt;/code&gt; 表示两边都有，但不一样&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;2,4a2,4&lt;/code&gt;：数字是&lt;strong&gt;闭区间&lt;/strong&gt;，&lt;code&gt;[2-4]&lt;/code&gt;行，需要&lt;code&gt;a&lt;/code&gt;dd 才能跟 file2 一样，【&lt;code&gt;a&lt;/code&gt;dd、 &lt;code&gt;c&lt;/code&gt;hange、 &lt;code&gt;d&lt;/code&gt;elete】&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;diff file1 file2 -y -W 100 | grep &amp;quot;&amp;gt;&amp;quot;&lt;/code&gt;：并排显示不同之处，每排宽度 100&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-y&lt;/code&gt;并排显示： &lt;code&gt;--suppress-common-lines&lt;/code&gt;仅显示不同的；&lt;code&gt;--left-column&lt;/code&gt;相同的仅在左边显示&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-w&lt;/code&gt;忽略所有空格，&lt;code&gt;-i&lt;/code&gt;忽略大小写，&lt;code&gt;-I &amp;lt;str&amp;gt;&lt;/code&gt;忽略字符串，&lt;code&gt;-b&lt;/code&gt; 忽略行尾空格，字符串中若干空格视为相等&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-C &amp;lt;num&amp;gt;&lt;/code&gt; 不同之处上下显示 num 行上下文&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-q&lt;/code&gt;仅显示是否相同&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;可用于比较 C 程序&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-r&lt;/code&gt;递归比较子目录，&lt;code&gt;-N&lt;/code&gt;独有的文件会显示&amp;quot;only in xxx&amp;quot;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;diff {dir1} {dir2} -Nrqy&lt;/code&gt;只显示文件夹中哪些文件不一样，不输出具体的文件&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;grep&#34;&gt;grep&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;-i&lt;/code&gt;：忽略大小写进行匹配&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-v&lt;/code&gt;：反向查找，只打印不匹配的行&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-E&lt;/code&gt;: 使用正经的正则表达式&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;：显示匹配行的行号&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-r&lt;/code&gt;：递归查找子目录中的文件&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-l&lt;/code&gt;：只打印匹配的文件名（小写 L）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;只打印匹配的行数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;sed&#34;&gt;sed&lt;/h2&gt;&#xA;&lt;p&gt;sed 命令的基本格式是&lt;code&gt;sed [-ni][-e&amp;lt;script&amp;gt;][-f&amp;lt;script文件&amp;gt;][文本文件]&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43;网络编程入门概念及api总结</title>
      <link>https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 02 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h1 id=&#34;linux-系统编程&#34;&gt;Linux 系统编程&lt;/h1&gt;&#xA;&lt;h2 id=&#34;chapter-1-系统编程入门&#34;&gt;Chapter 1 系统编程入门&lt;/h2&gt;&#xA;&lt;h3 id=&#34;gcc&#34;&gt;GCC&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;区别 GCC 与 G++&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;gcc 既能编译 c，也能编译 c++。只不过 gcc 在链接的时候，不能自动链接 C++的库。在编译阶段，g++会调用 gcc，二者是等价的。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;__cplusplus&lt;/code&gt;宏：g++编译 .c 文件时会定义，按照严谨的 cpp 语法去执行；gcc 编译 .cpp 文件时也会定义。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;gcc -lstdc++&lt;/code&gt;即可解决 gcc 链接不了 c++库的问题&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-D&lt;/code&gt;选项，可以指定一个编译时后的宏，可以方便调试。比如调试版本和 release 版本，就不用删除 log 了&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;静态库与动态库&#34;&gt;静态库与动态库&lt;/h3&gt;&#xA;&lt;h4 id=&#34;静态库&#34;&gt;静态库&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 编译,得到目标文件&#xA;gcc -c tes1.c tes2.c&#xA;# 打包成静态库: -r插入  -c  -s起名&#xA;ar -rcs libxxx.a tes1.o tes2.o&#xA;# 使用：指定库名、库位置、头文件&#xA;gcc -o demo tes1.o tes2.o -l xxx -L ./lib -I ./include&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;加载速度快，因为打包到程序里面了&lt;/li&gt;&#xA;&lt;li&gt;发布无需额外提供库，方便移植&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
