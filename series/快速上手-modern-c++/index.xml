<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>快速上手 &#34;Modern C&#43;&#43;&#34; on SHUAIKAI&#39;s Blog</title>
    <link>https://kaikaixixi.xyz/series/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-modern-c&#43;&#43;/</link>
    <description>Recent content in 快速上手 &#34;Modern C&#43;&#43;&#34; on SHUAIKAI&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 21 May 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kaikaixixi.xyz/series/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B-modern-c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>协程快速入门</title>
      <link>https://kaikaixixi.xyz/cpp/%E5%8D%8F%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</link>
      <pubDate>Wed, 21 May 2025 00:00:00 +0000</pubDate>
      <guid>https://kaikaixixi.xyz/cpp/%E5%8D%8F%E7%A8%8B%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;h1 id=&#34;协程快速上手&#34;&gt;协程快速上手&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是协程&#34;&gt;什么是协程？&lt;/h2&gt;&#xA;&lt;p&gt;协程就是一个可以暂停和恢复执行的&lt;strong&gt;函数&lt;/strong&gt;。别的函数是一镜到底，协程是走走停停。停下（被挂起）的时候，就是说当前线程可以去执行别的任务了，完了还能再回来&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么要有协程&#34;&gt;为什么要有协程&lt;/h2&gt;&#xA;&lt;p&gt;首先看看线程的历史。为什么会有线程呢，线程的作用是什么呢？&lt;/p&gt;&#xA;&lt;p&gt;是为了尽可能多的吃满CPU，发挥性能。当然，这是我们说的多线程并发的常用场景。但是最开始引入线程其实是为了解决一个异步IO的问题。&lt;/p&gt;&#xA;&lt;p&gt;一开始的电脑，程序员编辑完一个文件，按下保存，然后就可以去玩了。因为只有一个线程，在保存的时候，就不能干别的了。但是这显然是不合理的，磁盘在那吭哧吭哧写，但是cpu却是闲着的。闲着的cpu是否应该找点活干呢？&lt;/p&gt;&#xA;&lt;p&gt;后来有了多任务的概念（应该不是当前场景首创，较真的话需要深入考究），也就是多个线程。有了多个线程，保存的线程阻塞了，不影响编辑的线程。这就是多线程带来的异步，让IO进行的时候，CPU能空出来。&lt;/p&gt;&#xA;&lt;p&gt;&amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;随着计算机的发展，异步写磁盘的情况已经是小菜一碟了，但是又有了新的挑战，比如经典的C10K问题，也就是服务器单机1w并发请求处理。单个线程处理1w个请求必然会卡死。创建1w个线程，每个线程4M的栈，这就是40G的内存，那显然也不行。看来用线程实现的异步IO不中用了。&lt;/p&gt;&#xA;&lt;p&gt;那是时候引入单线程异步IO的概念了。用一个线程，就可以发起很多个IO操作。这需要：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一个IO多路复用的通知机制。一个接口，通知所有的IO时间。如果不是多路复用的，那必然就需要新的线程&lt;/li&gt;&#xA;&lt;li&gt;非阻塞IO（只需有IO发起操作，无需等IO完成）。阻塞了当前这个唯一的线程就被挂起了&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;todo: 简化一下&lt;/p&gt;&#xA;&lt;h2 id=&#34;深入理解协程&#34;&gt;深入理解协程&lt;/h2&gt;&#xA;&lt;p&gt;理解协程，最好的办法就是和线程进行类比：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从调度、挂起切换角度比较&#xA;&lt;ol&gt;&#xA;&lt;li&gt;线程由OS调度、切换，调用阻塞IO等会被挂起，IO就绪OS会将其恢复&lt;/li&gt;&#xA;&lt;li&gt;协程由用户调度、切换，由用户指定什么时候挂起，什么时候恢复。怎么指定呢？——通过&lt;code&gt;Awaiter&lt;/code&gt;指定，&lt;code&gt;await_suspend()&lt;/code&gt;描述协程挂起时执行什么动作（比如发起一次非阻塞IO然后等待，比如注册fd到epoll然后等待）；&lt;code&gt;await_resume()&lt;/code&gt;描述协程恢复时执行什么动作（比如读取就绪数据/向就绪fd发送）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;从编码角度比较。我们更习惯的都是以同步的方式编码&#xA;&lt;ol&gt;&#xA;&lt;li&gt;线程调用阻塞IO，比如read，发起一次IO，然后当前线程被OS阻塞，IO就绪时恢复。&lt;/li&gt;&#xA;&lt;li&gt;协程效用一个异步IO/非阻塞IO，发起一次任务。然后当前协程被阻塞，任务就绪时恢复。线程阻不阻塞OS知道，协程怎么知道哪个IO要阻塞呢？用&lt;code&gt;co_await&lt;/code&gt;标记。所以加上co_await后，就相当于告诉协程，这是一个“阻塞”IO，要阻塞协程。&lt;/li&gt;&#xA;&lt;li&gt;简单来说，阻塞IO阻塞整个线程，非阻塞IO阻塞协程（用co_await标记上：这对于协程来说是一个阻塞IO）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;从结果传出的角度&#xA;&lt;ol&gt;&#xA;&lt;li&gt;线程需要使用一个&lt;code&gt;std::promise&lt;/code&gt;，传递不是立马能获取到的结果&lt;/li&gt;&#xA;&lt;li&gt;协程也需要这么一个promise，它就是协程的&lt;code&gt;Task&amp;lt;T&amp;gt;&lt;/code&gt;，里面要求必须有一个&lt;code&gt;promise_type&lt;/code&gt;，这就是协程的promise，用于获取不是立马得到的结果&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;从第2点也可以看出：协程必须要搭配真正的异步IO才叫协程。因为&#xA;&lt;ol&gt;&#xA;&lt;li&gt;调用同步IO，OS管你这那的，直接阻塞整个线程了，它眼里可没有协程这么回事。&lt;/li&gt;&#xA;&lt;li&gt;创建线程实现异步IO，那不还是多线程等于？&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;类比完再想想，什么叫做，&lt;strong&gt;协程时由用户负责调度切换的协程&lt;/strong&gt;这句话，有没有更清晰？&lt;/p&gt;&#xA;&lt;h2 id=&#34;c20协程核心概念&#34;&gt;C++20协程核心概念&lt;/h2&gt;&#xA;&lt;h3 id=&#34;promise_type&#34;&gt;promise_type&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;&#xA;struct Task&amp;lt;T&amp;gt;::promise_type {&#xA;    T promised_value;&#xA;    std::exception_ptr exptr;&#xA;    T Get() {&#xA;        if(exptr) std::rethrow_excetion(exptr);&#xA;        return promised_value;&#xA;    }&#xA;    &#xA;    &#xA;    // 强制要求的函数：&#xA;    &#xA;    void get_return_object(){ return Task{std::coroutine_handle&amp;lt;promise_type&amp;gt;::from_promise(*this)}; }&#xA;    &#xA;    auto initial_suspend() { return std::suspend_never{}; }&#xA;    &#xA;    auto final_suspend() noexcept { return std::suspend_always{}; }&#xA;    &#xA;    void unhandled_exception() { exptr = std::current_excetion(); }&#xA;    &#xA;    template&amp;lt;typename U = T&amp;gt;&#xA;    require(std::is_same_v&amp;lt;U, void&amp;gt;)&#xA;    void return_void() {}&#xA;    &#xA;    template&amp;lt;typename U = T&amp;gt;&#xA;    require(std::is_convertible_v&amp;lt;U, T&amp;gt;)&#xA;    void return_value(U v){ promised_value = std::move(v); }&#xA;    &#xA;    template&amp;lt;std::convertible_to&amp;lt;T&amp;gt; From&amp;gt;&#xA;    std::suspend_always yield_value(From v) { promised_value = std::move(v); return {}; }&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;那么一个完整的task应该长什么样呢？&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
