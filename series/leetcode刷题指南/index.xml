<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode刷题指南 on SHUAIKAI&#39;s Blog</title>
    <link>https://kaikaixixi.xyz/series/leetcode%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</link>
    <description>Recent content in Leetcode刷题指南 on SHUAIKAI&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 11 Sep 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kaikaixixi.xyz/series/leetcode%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode刷题指南</title>
      <link>https://kaikaixixi.xyz/%E7%AE%97%E6%B3%95/leetcode%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sun, 11 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://kaikaixixi.xyz/%E7%AE%97%E6%B3%95/leetcode%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;h2 id=&#34;1-数据结构&#34;&gt;1. 数据结构&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-数组&#34;&gt;1.1 数组&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;循环数组问题&lt;/strong&gt;：把数组扩大为两倍即可，但不是真的扩大两倍，而是通过索引取模的方式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;12-链表&#34;&gt;1.2 链表&lt;/h3&gt;&#xA;&lt;p&gt;链表可以通过引入虚拟头节点 &lt;code&gt;ListNode *dummy = new ListNode{-1, nullptr}&lt;/code&gt; 来极大简化&lt;/p&gt;&#xA;&lt;ol start=&#34;0&#34;&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;**递归：**要区分基础情况和跳出情况，即可以有两种 return，比如：如果链表为空，那么返回。这时候的 return 并非是用来跳出递归的，而是一个 base 情况的判断，只有最基本的（最后一层递归）会用到。一系列操作，比如反转链表之后，再 return，则时候是退出递归的 return，即后面每一层递归想出栈都是走的这一条 return。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;反转链表&lt;/strong&gt;【递归】：反转从 &lt;code&gt;head-&amp;gt;next&lt;/code&gt; 开始的链表，然后拼接上第一个节点。&lt;strong&gt;base&lt;/strong&gt;：单节点链表&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;反转前 n 个元素&lt;/strong&gt;：反转从 &lt;code&gt;head-&amp;gt;next&lt;/code&gt; 开始的 &lt;code&gt;n-1&lt;/code&gt; 个元素，然后拼接。&lt;strong&gt;base&lt;/strong&gt;：n = 1&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;反转 [m, n] 的元素&lt;/strong&gt;：反转从 &lt;code&gt;head-&amp;gt;next&lt;/code&gt; 开始的 &lt;code&gt;[m-1, n - 1]&lt;/code&gt; 的元素，然后拼接。&lt;strong&gt;base&lt;/strong&gt;：m = 1，同上&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;倒序输出链表&lt;/strong&gt;：对链表进行&lt;mark&gt;后序遍历&lt;/mark&gt;，（递归的 base 是，head==nil）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;13-栈与队列&#34;&gt;1.3 栈与队列&lt;/h3&gt;&#xA;&lt;h4 id=&#34;单调队列&#34;&gt;单调队列&lt;/h4&gt;&#xA;&lt;p&gt;有这样一类问题：如何得到一个&lt;strong&gt;队列中的最值&lt;/strong&gt;？遍历，然后维护一个最值就好了。但这会有一个问题：当最值出队之后，次最值无从得知，需要再次遍历。可以参考例题：&lt;/p&gt;&#xA;&lt;p&gt;【&#xA;&lt;a href=&#34;https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;剑指 Offer：队列最大值&lt;/a&gt;&#xA;】，【&#xA;&lt;a href=&#34;https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;leetcode-1438. 绝对差不超过限制的最长连续子数组（解法二）&lt;/a&gt;&#xA;】&lt;/p&gt;&#xA;&lt;p&gt;如何快速得到一个队列中，&lt;em&gt;当前所有元素&lt;/em&gt;的最值呢？维护一个单调队列 queueMax，对入队元素 Value，如果 &lt;code&gt;queueMax.back() &amp;gt; value&lt;/code&gt;，则直接入队，否则一直 &lt;code&gt;queueMax.pop_back()&lt;/code&gt;，直至满足该条件。这样便可以保证：对原队列中所有元素，单调队列的队首，总是其最大值。如果原队列出队，使得最值出队，则单调队列中的下一个，仍是原队列中剩余元素的最值。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
