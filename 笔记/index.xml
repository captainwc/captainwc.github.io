<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>笔记s on SHUAIKAI&#39;s Blog</title>
    <link>https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 笔记s on SHUAIKAI&#39;s Blog</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 04 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>面向模式的软件架构 卷1 模式系统 读书笔记</title>
      <link>https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E5%90%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%8D%B71%E6%A8%A1%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 04 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/%E9%9D%A2%E5%90%91%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%8D%B71%E6%A8%A1%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h1 id=&#34;面向模式的软件架构-卷1模式系统读书笔记&#34;&gt;《面向模式的软件架构 卷1：模式系统》读书笔记&lt;/h1&gt;&#xA;&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;&#xA;&lt;p&gt;本书不仅仅是模式的目录，更是一套模式系统。模式（Pattern）是记录专家经验、解决特定设计问题的规范化方法。学习这些模式，能让我跳过多年的试错过程，直接站在巨人的肩膀上，构建出具备高可修改性、可重用性和可靠性的软件系统。本书提供的架构模式、设计模式和成例，分别从宏观结构、局部设计和语言细节三个层面提供了指导。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;第1章-模式patterns&#34;&gt;第1章 模式（Patterns）&lt;/h2&gt;&#xA;&lt;p&gt;本章系统地介绍了模式的概念和描述模式的原则。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;概念&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;总结与理解&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式是什么&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;模式是对在特定情境下，某个反复出现的问题的解决方案的描述，它详细说明了如何解决问题、为什么解决以及该方案的优缺点。模式不是最终的代码，而是抽象的设计智慧。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式的分类&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;模式分为三个抽象层次：&lt;strong&gt;架构模式 (Architectural Patterns)&lt;/strong&gt;（最高层，提供系统骨架），&lt;strong&gt;设计模式 (Design Patterns)&lt;/strong&gt;（中层，解决常见设计问题），&lt;strong&gt;成例 (Idioms)&lt;/strong&gt;（最低层，语言特定的模式）。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式之间的关系&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;模式并非孤立，它们相互关联、协作。一个架构模式可以由多个设计模式实现，一个设计模式的实现可能依赖于特定的成例。理解这种关系是构建模式系统的关键。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;第2章-架构模式architectural-patterns&#34;&gt;第2章 架构模式（Architectural Patterns）&lt;/h2&gt;&#xA;&lt;p&gt;架构模式是最高层的模式，旨在提供系统架构的整体骨架，决定了整个系统的组织结构和高层特性。&lt;/p&gt;&#xA;&lt;h3 id=&#34;22-从混乱到有序&#34;&gt;2.2 从混乱到有序&lt;/h3&gt;&#xA;&lt;h4 id=&#34;221-layers-模式分层&#34;&gt;2.2.1 Layers 模式（分层）&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;总结项&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;内容&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式总结/定义&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;一种将应用程序划分为多组子任务的结构化方式，其中每组子任务都位于特定抽象层。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;解决问题&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;管理复杂的系统结构，实现关注点分离，提升系统的可修改性、可维护性和可重用性。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式架构&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;系统被组织成一组抽象层级（Layer J），&lt;strong&gt;第J+1层只使用第J层的服务&lt;/strong&gt;。这种单向依赖关系保证了层级的清晰性。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优缺点总结&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优点&lt;/strong&gt;: 职责分离清晰，易于替换和修改特定层的实现，支持增量开发。 &lt;strong&gt;缺点&lt;/strong&gt;: 严格分层可能导致不必要的层间通信开销（性能损耗）；难以确定合适的抽象层级。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可能的应用方向&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;几乎所有大型软件系统，尤其是网络协议栈（如TCP/IP）、操作系统和企业级应用的三层/多层架构。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;222-pipes-and-filters-模式管道与过滤器&#34;&gt;2.2.2 Pipes and Filters 模式（管道与过滤器）&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;总结项&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;内容&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式总结/定义&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;一种适用于处理数据流的系统结构，将任务分解为一系列独立、顺序处理数据的单元。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;解决问题&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;应对数据处理流程中对灵活性、可重用性、可维护性和易于理解的要求。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式架构&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;由&lt;strong&gt;过滤器（Filters）&lt;/strong&gt; 和 &lt;strong&gt;管道（Pipes）&lt;/strong&gt; 组成。过滤器是独立的、处理输入流并产生输出流的组件。管道负责连接过滤器，传输数据流。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优缺点总结&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优点&lt;/strong&gt;: 组件高度解耦，可重用性极强；易于通过添加、替换或重新排列过滤器来修改处理流程。 &lt;strong&gt;缺点&lt;/strong&gt;: 仅限于数据流处理系统；数据格式约定是挑战；难以处理交互式或流式处理不适用的情况。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可能的应用方向&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;编译器前端（词法分析、语法分析），ETL（抽取、转换、加载）工具，UNIX Shell命令链。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;223-blackboard-模式黑板&#34;&gt;2.2.3 Blackboard 模式（黑板）&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;总结项&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;内容&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式总结/定义&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;一种用于解决没有明确解决策略的复杂问题的模式，多个专业子系统通过集思广益，逐步逼近可能的部分解。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;解决问题&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;解决问题领域知识分散、且缺乏确定性算法的复杂问题。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式架构&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;包含三个主要组件：&lt;strong&gt;黑板 (Blackboard)&lt;/strong&gt;（集中存储问题、部分解和推测），&lt;strong&gt;知识源 (Knowledge Sources)&lt;/strong&gt;（专用子系统，对黑板状态变化做出反应），&lt;strong&gt;控制组件 (Control)&lt;/strong&gt;（驱动推理过程，决定知识源的执行顺序）。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优缺点总结&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优点&lt;/strong&gt;: 适合启发式问题求解和实验性系统；高度模块化，易于添加新的知识源。 &lt;strong&gt;缺点&lt;/strong&gt;: 黑板可能成为性能瓶颈；知识源之间的协作逻辑（控制组件）复杂难设计。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可能的应用方向&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;语音识别，模式识别，AI专家系统，机器人控制。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;23-分布式系统&#34;&gt;2.3 分布式系统&lt;/h3&gt;&#xA;&lt;h4 id=&#34;broker-模式中间人&#34;&gt;Broker 模式（中间人）&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;总结项&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;内容&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式总结/定义&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;用于设计包含通过远程服务调用交互的组件的分布式软件系统。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;解决问题&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;应对分布式系统中客户端和服务端的解耦、位置透明性以及通信协议的隐藏。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式架构&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;中间人 (Broker)&lt;/strong&gt; 负责协调组件间的通信。主要组件包括客户端、服务器、中间人、客户端代理和服务器端代理。中间人利用名称服务实现位置透明。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优缺点总结&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优点&lt;/strong&gt;: 客户端无需知道服务的位置，实现了高度的位置透明性；解耦客户端和服务端，提高了系统的可扩展性。 &lt;strong&gt;缺点&lt;/strong&gt;: 引入了额外的中间层，增加了通信延迟；中间人本身可能成为性能瓶颈或单点故障。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可能的应用方向&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;CORBA/COM等分布式对象系统，面向服务的架构 (SOA)，微服务架构中的服务注册与发现。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;24-交互式系统&#34;&gt;2.4 交互式系统&lt;/h3&gt;&#xA;&lt;h4 id=&#34;241-model-view-controller-模式mvc&#34;&gt;2.4.1 Model-View-Controller 模式（MVC）&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;总结项&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;内容&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式总结/定义&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;将交互式应用程序划分为三个组件：核心功能、表示和控制。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;解决问题&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;将用户界面（表示和控制）与业务逻辑（核心功能）分离，提高系统的可修改性和可重用性。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式架构&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模型 (Model)&lt;/strong&gt; (封装业务数据和逻辑)；&lt;strong&gt;视图 (View)&lt;/strong&gt; (展示数据)；&lt;strong&gt;控制器 (Controller)&lt;/strong&gt; (处理用户输入)。视图通过&lt;strong&gt;Publisher-Subscriber模式&lt;/strong&gt;观察模型变化，确保同步。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优缺点总结&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优点&lt;/strong&gt;: 职责分离清晰，易于修改和扩展用户界面；支持同一模型拥有多个视图。 &lt;strong&gt;缺点&lt;/strong&gt;: 增加了系统的复杂性（引入了许多类）；视图和控制器有时耦合较紧密。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可能的应用方向&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;桌面GUI应用，Web应用程序框架（许多Web MVC框架是变体）。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;242-presentation-abstraction-control-模式pac&#34;&gt;2.4.2 Presentation-Abstraction-Control 模式（PAC）&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;总结项&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;内容&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式总结/定义&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;定义了一种适用于交互式软件系统的结构，由相互协作的&lt;strong&gt;智能体（Agents）&lt;/strong&gt; 组成的层次结构。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;解决问题&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;解决MVC模式在大型、复杂、需要多层次控制和协调的交互式系统中的扩展性问题。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式架构&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;每个智能体都包含：&lt;strong&gt;表示 (Presentation)&lt;/strong&gt;、&lt;strong&gt;抽象 (Abstraction)&lt;/strong&gt; (功能核心) 和 &lt;strong&gt;控制 (Control)&lt;/strong&gt; (通信和协调)。控制组件是智能体通信的枢纽。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优缺点总结&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优点&lt;/strong&gt;: 层次化和模块化程度更高，更适合复杂的系统；更好的关注点分离。 &lt;strong&gt;缺点&lt;/strong&gt;: 比MVC更复杂，理解和实现难度更高；智能体间的通信和协调逻辑复杂。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可能的应用方向&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;复杂的图形用户界面，具有多层交互和协调的系统。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;25-可适应系统&#34;&gt;2.5 可适应系统&lt;/h3&gt;&#xA;&lt;h4 id=&#34;251-microkernel-模式微核&#34;&gt;2.5.1 Microkernel 模式（微核）&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;总结项&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;内容&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式总结/定义&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;适用于必须能够适应需求不断变化的系统，将最基本的功能核心与扩展功能分离。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;解决问题&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;应对核心系统需要高适应性、可扩展性，并支持多种定制化需求的问题。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式架构&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;微核 (Microkernel)&lt;/strong&gt; 位于最底层，只提供最小的必要核心功能。扩展功能则作为&lt;strong&gt;外部服务器 (External Servers)&lt;/strong&gt; 运行，通过微核提供的机制进行协作。微核充当插座。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优缺点总结&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优点&lt;/strong&gt;: 扩展性高，适应性强；系统故障隔离性好（服务器间的独立性）；易于移植。 &lt;strong&gt;缺点&lt;/strong&gt;: 由于功能大部分在微核外，需要大量的进程间通信（IPC），可能造成性能损耗。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可能的应用方向&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;操作系统（如Linux、Windows NT的早期设计），产品线架构，插件式应用框架。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;252-reflection-模式反射&#34;&gt;2.5.2 Reflection 模式（反射）&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;总结项&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;内容&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式总结/定义&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;提供了一种动态修改软件系统的结构和行为的机制。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;解决问题&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;系统需要极高的运行时适应性和可配置性，允许系统在运行时检查并修改自身的结构和行为。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;模式架构&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;由&lt;strong&gt;基层 (Base Level)&lt;/strong&gt; 和 &lt;strong&gt;元层 (Meta Level)&lt;/strong&gt; 组成。基层包含应用逻辑，元层包含关于基层的元信息（如类型、函数调用机制），元层提供了检查和修改基层的接口。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优缺点总结&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;优点&lt;/strong&gt;: 极高的动态适应性；能够实现高级、复杂的运行时行为（如动态配置、AOP）。 &lt;strong&gt;缺点&lt;/strong&gt;: 极大地增加了系统的复杂性；运行时修改可能引入难以预料的错误；性能开销大。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可能的应用方向&lt;/strong&gt;&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;动态语言运行时，面向方面的编程（AOP），软件配置管理系统。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;第3章-设计模式design-patterns&#34;&gt;第3章 设计模式（Design Patterns）&lt;/h2&gt;&#xA;&lt;p&gt;设计模式在架构模式的框架下，解决了软件系统局部结构和协作方面的常见问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>初等数学回忆录</title>
      <link>https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6%E5%9B%9E%E5%BF%86%E5%BD%95/</link>
      <pubDate>Fri, 16 May 2025 00:00:00 +0000</pubDate>
      <guid>https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/%E5%88%9D%E7%AD%89%E6%95%B0%E5%AD%A6%E5%9B%9E%E5%BF%86%E5%BD%95/</guid>
      <description>&lt;h1 id=&#34;初等数学回忆录&#34;&gt;初等数学回忆录&lt;/h1&gt;&#xA;&#xA;          &lt;link rel=&#34;stylesheet&#34; href=&#34;https://kaikaixixi.xyz/css/vendors/admonitions.e8f9d71468684b38dcc32a3631441f47b6ee45ce52f3bcc31201e76cc2b0a193.css&#34; integrity=&#34;sha256-6PnXFGhoSzjcwyo2MUQfR7buRc5S87zDEgHnbMKwoZM=&#34; crossorigin=&#34;anonymous&#34;&gt;&#xA;  &lt;div class=&#34;admonition reference&#34;&gt;&#xA;    &lt;div class=&#34;admonition-header&#34;&gt;&#xA;      &lt;svg t=&#34;1742461876844&#34; class=&#34;icon&#34; viewBox=&#34;0 0 1024 1024&#34; version=&#34;1.1&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34; p-id=&#34;48681&#34; width=&#34;200&#34; height=&#34;200&#34;&gt;&lt;path d=&#34;M65.42832 207.541555c1.419105-76.228262 70.647064-144.132337 147.334027-142.150095 199.191771-0.610236 398.376374-0.255971 597.569168-0.203753-0.258019 198.478122 0.308189 397.006415-0.307166 595.484538-185.424608-0.308189-370.898363 0.099317-556.379285-0.203753-41.290223-0.610236-82.376694 23.058921-101.272498 60.082614-17.062025 30.879358-16.402643 69.986657-0.863135 101.371815 17.472603 36.771818 56.783656 61.19865 97.310061 62.116051 211.991361-0.104436 423.930504 0.05017 635.917769-0.050171 0.100341-223.46502-0.054266-446.880893 0.050171-670.345913 24.783144-0.05017 49.617483 0 74.405746 0 0.149487 248.402771 0.05017 496.855712 0.050171 745.30763-247.084007 0-494.21716 0.05017-741.303214-0.049147-58.405491 0.504775-115.542387-34.743501-139.458301-88.32342-10.871614-23.112163-13.718016-48.908954-13.152831-74.147727 0.149487-196.296223-0.054266-392.592446 0.099317-588.888669z&#34; p-id=&#34;48682&#34;&gt;&lt;/path&gt;&lt;path d=&#34;M288.89334 735.53362c173.850609-0.049146 347.639784-0.153583 521.438175 0.050171-0.099317 24.481098 0.05017 49.011343-0.099317 73.542611-173.749244-0.05017-347.488249 0.049146-521.239541 0-0.19761-24.580415-0.148463-49.061513-0.099317-73.592782z&#34; p-id=&#34;48683&#34;&gt;&lt;/path&gt;&lt;/svg&gt;&#xA;&#xA;      &lt;span&gt;关于latex语法&lt;/span&gt;&#xA;    &lt;/div&gt;&#xA;      &lt;div class=&#34;admonition-content&#34;&gt;&#xA;        &lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;https://kaikaixixi.xyz/%e5%b7%a5%e5%85%b7%e4%bd%bf%e7%94%a8/%e5%b8%b8%e7%94%a8%e6%95%b0%e5%ad%a6%e7%ac%a6%e5%8f%b7%e7%9a%84latex%e8%a1%a8%e7%a4%ba/&#34;  target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; &gt;常用数学符号的latex表示 | SHUAIKAI&amp;rsquo;s Blog&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&#xA;&lt;a href=&#34;latex%e9%80%9f%e6%9f%a5%e6%89%8b%e5%86%8c.pdf&#34; &gt;Latex速查手册.pdf&lt;/a&gt;&#xA;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;      &lt;/div&gt;&#xA;  &lt;/div&gt;&#xA;&lt;h2 id=&#34;坐标系&#34;&gt;坐标系&lt;/h2&gt;&#xA;&lt;h3 id=&#34;极坐标&#34;&gt;极坐标&lt;/h3&gt;&#xA;$$&#xA;\begin{cases}&#xA;x = \rho\cos\theta \\&#xA;y = \rho\sin\theta&#xA;\end{cases}&#xA;\qquad&#xA;\begin{cases}&#xA;\rho^2 = x^2+y^2 \\&#xA;\tan\theta = \frac{y}{x}\ (x\neq 0)&#xA;\end{cases}&#xA;$$&lt;p&gt;由上式即可完成坐标系互换。（常用技巧比如两边同时乘 $\rho$ 等在此不表）&lt;/p&gt;</description>
    </item>
    <item>
      <title>C&#43;&#43;网络编程入门概念及api总结</title>
      <link>https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Sun, 02 Apr 2023 00:00:00 +0000</pubDate>
      <guid>https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h1 id=&#34;linux-系统编程&#34;&gt;Linux 系统编程&lt;/h1&gt;&#xA;&lt;h2 id=&#34;chapter-1-系统编程入门&#34;&gt;Chapter 1 系统编程入门&lt;/h2&gt;&#xA;&lt;h3 id=&#34;gcc&#34;&gt;GCC&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;区别 GCC 与 G++&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;gcc 既能编译 c，也能编译 c++。只不过 gcc 在链接的时候，不能自动链接 C++的库。在编译阶段，g++会调用 gcc，二者是等价的。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;__cplusplus&lt;/code&gt;宏：g++编译 .c 文件时会定义，按照严谨的 cpp 语法去执行；gcc 编译 .cpp 文件时也会定义。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;gcc -lstdc++&lt;/code&gt;即可解决 gcc 链接不了 c++库的问题&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;-D&lt;/code&gt;选项，可以指定一个编译时后的宏，可以方便调试。比如调试版本和 release 版本，就不用删除 log 了&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;静态库与动态库&#34;&gt;静态库与动态库&lt;/h3&gt;&#xA;&lt;h4 id=&#34;静态库&#34;&gt;静态库&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 编译,得到目标文件&#xA;gcc -c tes1.c tes2.c&#xA;# 打包成静态库: -r插入  -c  -s起名&#xA;ar -rcs libxxx.a tes1.o tes2.o&#xA;# 使用：指定库名、库位置、头文件&#xA;gcc -o demo tes1.o tes2.o -l xxx -L ./lib -I ./include&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;加载速度快，因为打包到程序里面了&lt;/li&gt;&#xA;&lt;li&gt;发布无需额外提供库，方便移植&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>征服C指针笔记</title>
      <link>https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/%E5%BE%81%E6%9C%8Dc%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 04 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://kaikaixixi.xyz/%E7%AC%94%E8%AE%B0/%E5%BE%81%E6%9C%8Dc%E6%8C%87%E9%92%88/</guid>
      <description>&lt;h1 id=&#34;征服-c-指针&#34;&gt;征服 C 指针&lt;/h1&gt;&#xA;&lt;h2 id=&#34;关于指针-初步&#34;&gt;关于指针 初步&lt;/h2&gt;&#xA;&lt;h3 id=&#34;指针类型定义&#34;&gt;指针类型定义&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;指针类型&lt;/strong&gt; 可由函数类型、对象类型或不完全的类型派生。派生指针类型的类，称为&lt;mark&gt;引用类型&lt;/mark&gt;。指针类型描述这样一个对象：该类对象的值，提供对该引用类型实体的引用。由引用类型 T 派生的指针类型，有时称为*“（指向）T 的指针*。从引用类型构造指针类型的过程，称为*&amp;ldquo;指针类型的派生”*。这些构造派生类型的方法可以递归地应用。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;和基本类型一样，指针也有：指针类型，指针类型的变量，指针类型的值&lt;/p&gt;&#xA;&lt;h3 id=&#34;指针与地址关系&#34;&gt;指针与地址关系&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;指针就是地址。对么？&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;无论是用&lt;code&gt;%d, %p, %x&lt;/code&gt;,都能输出指针，指针就是&lt;code&gt;unsigned int&lt;/code&gt;。似乎这样理解也不无道理。但是需要指出的是，这是与环境有关的。&lt;strong&gt;指针的长度是固定的，无论其是指向什么类型&lt;/strong&gt;，可以参见下面的例子：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int    *p1;&#xA;double *p1;&#xA;char   *p3;&#xA;printf(&amp;quot;%d %d %d\n&amp;quot;, sizeof(p1), sizeof(p2), sizeof(p3));&#xA;// 输出：&#xA;8 8 8&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;既然指针是地址，那指向 int 指向 double 有必要区分么？有的。&lt;strong&gt;仅仅告知内存地址，不告知在那个地址上的数据类型，是无法正确取出值来的&lt;/strong&gt;。&#xA;题外话，指针的&lt;mark&gt;强制类型转换&lt;/mark&gt;，也只是改变对内容的解释方法，指针的长度是固定不变的&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int   x = 0x00000041;&#xA;char *p;&#xA;p = (char*)&amp;amp;x;&#xA;pintf(&amp;quot;%c\n&amp;quot;, p);&#xA;// 输出：&#xA;A&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;指针就是地址，对指针 +1，指针不应该就前进一个字节么？&#xA;当然不是，对指针 +n，指针前进“当前指针指向的数据类型长度 $\times$n&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;空指针&#34;&gt;空指针&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;空指针&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;确保它和任何非空指针进行比较都不会相等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;只有&lt;code&gt;NULL&lt;/code&gt;，无论对方指向什么类型，都可以进行赋值和比较&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;null-0-和-0&#34;&gt;NULL， 0 和 &amp;lsquo;\0&amp;rsquo;&lt;/h4&gt;&#xA;&lt;p&gt;在&lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;中，NULL 定义如下：&lt;code&gt;#define NULL 0&lt;/code&gt;，那么空指针不就是为 0 的地址么？大部分环境中确实是这样，但这么说是不准确的。（原作中说的我也没听懂要说什么，但为了便于阅读，还是写 NULL 吧，又不费劲？）不过有一点：&lt;em&gt;在 C 语言中，当常量 0 处于应该作为指针的上下文中时，他就作为空指针使用&lt;/em&gt;，所以：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
